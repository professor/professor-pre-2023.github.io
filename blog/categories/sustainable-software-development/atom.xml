<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sustainable Software Development | Todd Sedano]]></title>
  <link href="http://professor.github.io/blog/categories/sustainable-software-development/atom.xml" rel="self"/>
  <link href="http://professor.github.io/"/>
  <updated>2018-12-01T14:59:05-08:00</updated>
  <id>http://professor.github.io/</id>
  <author>
    <name><![CDATA[Todd Sedano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sustainable Software Development]]></title>
    <link href="http://professor.github.io/toddsedano/2017/07/14/sustainable-software-development-compared-to-extreme-programming.html"/>
    <updated>2017-07-14T08:05:00-07:00</updated>
    <id>http://professor.github.io/toddsedano/2017/07/14/sustainable-software-development-compared-to-extreme-programming</id>
    <content type="html"><![CDATA[<p>There are several ways in which Sustainable Software Development has evolved from Extreme Programming (XP)</p>

<p>Sustainable Software Develpoment</p>

<ul>
  <li><em>combines user centered design with agile software development</em>. Product designers apply design thinking and user research to understand what product and features to build. Extreme Programming relies on an onsite customer to tell the developers what to build. This is problematic in two ways. Often an onsite customer is unaviable, impractical, or too expensive to have on a team. Onsite customers are not trained in design thinking and information architecture.</li>
  <li><em>reduces the commitment level of the team to the work in progress</em>, the stories that each developer is currently working on. Unlike Extrmee Programming, the team does not commit to an amount of work to be done during a weekly cycle or iteration. There are no iterations in Sustinable Software Development.</li>
  <li><em>focuses the technical practices on two main goals</em>
      <ol>
         <li>caretaking the code</li>
          <li>removing knowledge silos</li>
      </ol>
      Extreme Programming has many practices around improving code quality, but removing knowledge silos is not an explicit goal.
  </li>
  <li><em>replaces predictions with focusing on "what is the minimal that we need to ship?"</em> Planning Extreme Programming utilizes the team's velocity and backlog to create burn down charts for forecasting the team's progress. Like Extreme Progamming, the team maintains a shippable product. 
  <li><em>identifies and removes software development waste</em>. Weekly retros identify wastes and the team removes wastes with action items and chores.   
</ul>


<p>Both Sustainable Software Development and Extreme Programming deal with the tension of dates and features by asking &ldquo;how do we reduce scope?&rdquo; and &ldquo;what should be done first?&rdquo; In other words, developer happiness and sustainability is achieved by prioritizing the work.</p>

<p>This table compares Sustainable Software Development to Extreme Programming (XP). A more detailed analysis follows after the table.</p>

<table class=comparison>
  <tr>
    <th>Sustainable Software Development</th>
    <th>Extreme Programming 2.0 (XP 1.0 names)</th>
  </tr>
  <tr class="same">
    <td>
      Balanced Team</td>
    <td>Whole Team (Balanced Team)</td>
  </tr>  
  <tr>
    <td>Track One Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">User research</td>
    <td>Real Customer Involvement<sup>C</sup> (On-site customer)<br/>
        It is impractical to have an onsite customer.
    </td>
  </tr>
  <tr>
    <td class="ident">User validation</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Road Mapping</td>
    <td>Quarterly Cycle (Planning Game, Small Releases)</td>
  </tr>
  <tr>
    <td class="ident">Story writing</td>
    <td>Stories</td>
  </tr>
  <tr>
    <td class="ident">Story refining</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Project startup</td>
    <td></td>
  </tr>
  <tr>
    <td>Track Two Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Caretaking the Code</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident2">Clean code</td>
    <td>Code and Tests<sup>C</sup></td>
  </tr>
  <tr>
    <td class="ident2">Fast test suite and builds</td>
    <td>Ten-minute Build</td>
  </tr>
  <tr>
    <td class="ident2">Test Driven Development / BDD</td>
    <td>Test-First Programming</td>
  </tr>
  <tr>
    <td class="ident2">Team code ownership</td>
    <td>Shared Code<sup>C</sup> (Collective ownership)</td>
  </tr>
  <tr>
    <td class="ident2"> Continuous refactoring</td>
    <td>Incremental Design (Simple Design
Refactoring)</td>
  </tr>    
  <tr>
    <td class="ident2">Integrate frequently</td>
    <td>Continuous Integration and <br/>
        Single Code Base<sup>C</sup><br/>
        branches live a few hours at most</td>
  </tr>  
  <tr>
    <td class="ident2">Frequent releases<br/>
      Each team releases when features are done or at a given cadence</td>
    <td>Daily Deployment<sup>C</sup></td>
  </tr>
  <tr>
    <td class="ident2">Acceptance / staging environment</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident2">Build system</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident2">Stop on red builds</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident">Remove Knowledge silos</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident2">Continuous pair programming</td>
    <td>Pair Programming</td>
  </tr>
  <tr>
    <td class="ident2"> Overlapping pair rotations</td>
    <td>N/A</td>
  </tr>


  <tr>
    <td>Boundary Spanning Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Backlog grooming</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td class="ident">Accepting stories</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident">Story showcase meeting</td>
    <td>Weekly Cycle (Iteration Planning Meetings)</td>
  </tr>  


  <tr>
    <td>Project Management Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Core work hours</td>
    <td>Energized Work (<em>40-hr week)</em></td>
  </tr>
  <tr>
    <td class="ident">Stand-up</td>
    <td>N/A</td>
  </tr>  
  <tr>
    <td class="ident">Retro</td>
    <td>N/A</td>
  </tr>  
  <tr>
    <td class="ident">Flexible scope contracts </td>
    <td>Negotiated Scope Contract<sup>C</sup></td>
  </tr>
  <tr>
    <td class="ident">No overtime</td>
    <td>Energized Work (<em>40-hr week)</em></td>
  </tr>
  <tr>
    <td>
      Shared Schedule, Be Present</td>
    <td>Sit Together</td>
  </tr>
  <tr>
    <td>Not needed<br/>
      Agile project management tools (such a Pivotal Tracker)<br/>
       provide more value than a physical board showing project status. 
      </td>
    <td>Informative Workspace</td>
  </tr>
  <tr>
    <td>Not needed<br/>
        there is no commitment to each week</td>
    <td>Slack</td>
  </tr>
  <tr>
    <td>Not needed for all projects</td>
    <td>Incremental Deployment<sup>C</sup><br/>
        slowly replace a legacy systems</td>
  </tr>
  <tr>
    <td>Allocations<br/>
        Move engineers where needed</td>
    <td>Shrinking Teams<sup>C</sup><br/>
        Team Continuity<sup>C</sup></td>
  </tr>
  <tr>
    <td>Optional, depends on situation</td>
    <td>Root-cause analysis<sup>C</sup></td>
  </tr>
  <tr>
    <td></td>
    <td>Pay-per-use<sup>C</sup></td>
  </tr>
</table>




<br/>


<p><sup>C</sup> are optional XP 2.0 Corollary Practices</p>

<p>For a team transitioning to Extreme Programming, Beck recommends starting with the primary practices. Beck claims that “the primary practices are useful independent of what else you are doing” resulting in an immediate improvement, whereas the corollary practices work well once a team has implemented the primary practices. Extreme programming is not dogmatic about the list of practices. The team chooses which practices to apply.</p>

<p>Once a team has implemented the primary practices, then the team can start implementing the corollary practices. Beck says that it seems “difficult or dangerous to implement [the corollary practices] before completing the preliminary work of the primary practices” [1].</p>

<br/>


<table class=comparison>
  <tr>
    <th>Sustainable Software Development</th>
    <th>Extreme Programming 2.0 (XP 1.0 names)</th>
  </tr>
  <tr class="same">
    <td>
      Balanced Team</td>
    <td><b>Whole Team</b> (Balanced Team)
        Whole team is also known as cross-functional teams. Include people on the team with the skills needed for success. Beck points out that a sense of team fulfills an individual’s psychological needs. “We belong. We are in this together. We support each others’ work, growth, and learning.” [1]
    </td>
  </tr>  
  <tr>
    <td>Track One Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">User research</td>
    <td><b>Real Customer Involvement</b><sup>C</sup> (On-site customer)
        Make the customer a part of the team. “The point of customer involvement is to reduce wasted effort by putting the people with the needs in direct contact with the people who can fill those needs” [1]. Even if a customer is busy, involving them whenever possible is preferred to not involving them at all. In this situation, the team needs to find alternative ways of validating features with users.<br/>    
        It is impractical to have an onsite customer.
    </td>
  </tr>
  <tr>
    <td class="ident">User validation</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Road Mapping</td>
    <td><b>Quarterly Cycle</b> (Planning Game, Small Releases)
        Each quarter, the team identifies the stories for the next quarter. During a meeting, the team identifies bottlenecks, initiates repairs, plans the feature sets for the quarter, and selects a quarter’s worth of stories.
    </td>
  </tr>
  <tr>
    <td class="ident">Story writing</td>
    <td><b>Stories</b>
        Stories are “units of customer-visible functionality” [1]. Stories have a name and a description or graphical depiction. Stories track the work to be done.
    </td>
  </tr>
  <tr>
    <td class="ident">Story refining</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Project startup</td>
    <td></td>
  </tr>
  <tr>
    <td>Track Two Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Caretaking the Code</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident2">Clean code</td>
    <td><b>Code and Tests</b><sup>C</sup>
        The tests and code are the only permanent artifacts. Everything else (e.g. documentation) is generated from the code. Anything that contributes to what the system does today and what it will do tomorrow is valuable, “everything else is waste” [1].    
    </td>
  </tr>
  <tr>
    <td class="ident2">Fast test suite and builds</td>
    <td>Ten-minute Build<br/>
        Building the code and running the test suite should be automated and short. Longer builds increase the feedback loop.
    </td>
  </tr>
  <tr>
    <td class="ident2">Test Driven Development / BDD</td>
    <td>Test-First Programming<br/>
        The developers write tests before writing code. Every production line of code is preceded by a test. Test-first programming addresses several concerns: scope-creep, coupling and cohesion, trust, and rhythm. The practice mitigates against scope-creep; without a clear goal, a programmer can easily write more code than is necessary. The practice improves coupling and cohesion as easy-to-test code often has beneficial design qualities. The practice builds trust in the code as engineers trust tested code more than un-tested code. The practice produces rhythm as it provides a cadence of accomplishing goals.
     </td>
  </tr>
  <tr>
    <td class="ident2"><b>Team code ownership</b> is the ability for any developer on a team to change any of the team’s code.</td>
    <td><b>Shared Code</b><sup>C</sup> (Collective ownership)
        Everyone on the team can modify any of the system. When engineers sees something broken, they fix it.<br/>
    </td>
  </tr>
  <tr>
    <td class="ident2"> Continuous refactoring</td>
    <td>Incremental Design (Simple Design Refactoring)<br/>
        Build the system incrementally and evolve the design every day. In the past, software teams might often had long design phases that assumed features would not change. When the team’s understanding of the system changes, make incremental changes to the system to align the code’s design with the team’s desired goal. Teams routinely remove duplication.
   </td>
  </tr>    
  <tr>
    <td class="ident2">Integrate frequently</td>
    <td><b>Continuous Integration</b>
        When working on new features, routinely integrate new code into the master code repository. Avoid long-lived branches. Beck suggests un-integrated code live on its own “no more than a couple of hours” [1]. The longer the team waits to integrate, the more unpredictable and expensive integration becomes.<br/> 
        <b>Single Code Base</b><sup>C</sup>
        Ideally there is only one branch of the code. Multiple branches, (e.g. for releases, or customers) creates extra work. Branches live a few hours at most.
        branches live a few hours at most
        </td>
  </tr>  
  <tr>
    <td class="ident2">Frequent releases<br/>
      Each team releases when features are done or at a given cadence</td>
    <td>Daily Deployment<sup>C</sup><br/>
        Every day put a new version of the code into production.
    </td>
  </tr>
  <tr>
    <td class="ident2">Acceptance / staging environment</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident2">Build system</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident2">Stop on red builds</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident">Remove Knowledge silos</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident2">Continuous pair programming</td>
    <td>Pair Programming<br/>
        Every part of a production system is written by two programmers sitting side by side. The pair works together to solve problems, keep each other on task, learn from each other, and abide by the team’s practices.
    </td>
  </tr>
  <tr>
    <td class="ident2"> Overlapping pair rotations</td>
    <td>N/A</td>
  </tr>


  <tr>
    <td>Boundary Spanning Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Backlog grooming</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td class="ident">Accepting stories</td>
    <td>(implied)</td>
  </tr>
  <tr>
    <td class="ident">Story showcase meeting</td>
    <td>Weekly Cycle (Iteration Planning Meetings)<br/>
        Each week, the team accepts a certain amount of work to accomplish. During a meeting at the beginning of the week, the team reviews progress to date, the customer chooses a week’s worth of stories, and the engineers decompose the stories into tasks and individually estimate each task. “The goal is to have deployable software at the end of the week which everyone can celebrate as progress” [1].    
    </td>
  </tr>  


  <tr>
    <td>Project Management Practices</td>
    <td></td>
  </tr>
  <tr>
    <td class="ident">Core work hours</td>
    <td>Energized Work (<em>40-hr week)</em></td>
  </tr>
  <tr>
    <td class="ident">Stand-up</td>
    <td>N/A</td>
  </tr>  
  <tr>
    <td class="ident">Retro</td>
    <td>N/A</td>
  </tr>  
  <tr>
    <td class="ident">Flexible scope contracts </td>
    <td>Negotiated Scope Contract<sup>C</sup><br/>
        “Write contracts for software development that fix time, costs, and quality but call for an ongoing negotiation of the precise scope of the system.” [1]
    </td>
  </tr>
  <tr>
    <td class="ident">No overtime</td>
    <td>Energized Work (<em>40-hr week)</em><br/>
        “Work only as many hours as you can be productive and only as many hours as you can sustain” [1]. Working longer hours may make the team less productive. Team members need to take care of themselves; this includes staying home to rest when sick. The work patterns of the team should be sustainable in the long run.
    </td>
  </tr>
  <tr>
    <td>
      Shared Schedule, Be Present</td>
    <td>Sit Together<br/>
        Software development is a collaborative endeavor. Co-locating teams increases collaboration. Distributed teams are still possible, yet “Sit Together predicts that the more face time you have, the more humane and productive the project” [1]
    </td>
  </tr>
  <tr>
    <td>Not needed<br/>
      Agile project management tools (such a Pivotal Tracker)<br/>
      provide more value than a physical board showing project status. 
      </td>
    <td>Informative Workspace<br/>
        “An interested observer should be able to walk into the team space and get a general idea of how the project is going in fifteen seconds” [1]. The team can modify the workspace to make it more conducive for their work.
    </td>
  </tr>
  <tr>
    <td>Not needed<br/>
        there is no commitment to each week</td>
    <td>Slack<br/>
        During the weekly cycle meeting, include tasks in the plan that the team can drop if the team gets behind. Adding slack to the schedule enables a sustainable work environment.
    </td>
  </tr>
  <tr>
    <td>Not needed for all projects</td>
    <td>Incremental Deployment<sup>C</sup><br/>
        Switch between a legacy system and a replacement system in incremental steps. Avoid a hard switch over from a legacy system to a new system.<br/>
        slowly replace a legacy systems</td>
  </tr>
  <tr>
    <td>Allocations<br/>
        Move engineers where needed</td>
    <td>Shrinking Teams<sup>C</sup><br/>
        Try to improve team efficiency so that the team can shrink in size. When a team becomes more productive, re-allocated extraneous team members to other teams.<br/> 
        Team Continuity<sup>C</sup><br/>
        “Keep effective teams together” [1]. People are not fungible, and building relationships is part of creating a high performing team. Rotating people through teams helps spread knowledge.
    </td>
  </tr>
  <tr>
    <td>Optional, depends on situation</td>
    <td>Root-cause analysis<sup>C</sup>
        When a defect occurs, determine why it happened. Modify testing strategy to prevent that kind of mistake from happening again. Write an automated system test and an automated unit test then fix the code.<br/>
    </td>
  </tr>
  <tr>
    <td></td>
    <td>Pay-per-use<sup>C</sup><br/>
        Pay-per-use provides alignment between revenue and the features that generate the revenue. “Connecting money flow directly to software development provides accurate, timely information with which to drive improvement” [1].
    </td>
  </tr>
</table>


<p>[1] K. Beck and C. Andres. Extreme Programming Explained: Embrace Change (2nd Edition). Addison-Wesley Professional, 2004.</p>
]]></content>
  </entry>
  
</feed>
